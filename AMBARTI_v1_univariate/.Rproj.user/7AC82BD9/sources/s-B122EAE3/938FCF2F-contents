# Header ------------------------------------------------------------------

# An Additive Main effects and Multiplicative Interaction (AMMI) effects model

# A Bayesian version of the AMMI model as specified here: https://link.springer.com/content/pdf/10.1007/s13253-014-0168-z.pdf (JosseE et al JABES 2014)
# Andrew Parnell / Danilo Sarti

# In this file we simulate from the AMMI model specified in the paper above, then fit it using JAGS. Finally we present a worked example
# There are two jags code parts below. The first is for a single interaction decomposition effect. The second is for a general AMMI model which is more realistic

# Some boiler plate code to clear the workspace, set the working directory, and load in required packages
# rm(list = ls())
library(R2jags)
library(ggplot2)
library(tidyverse)
# Maths -------------------------------------------------------------------

# Description of the Bayesian model fitted in this file

# Notation
# Y_ij = response (e.g. yield) for genotype i and environment j, i = 1, ..., I genotypes and j = 1, ..., J environments
# mu is the grand mean
# alpha_i is the genotype effect
# beta_j is the environment effect
# lambda_q is the q-th eigenvalue q = 1,.., Q of the interaction matrix
# Q is the number of components used to model the interaction. Usually Q is fixed at a small number, e.g. 2
# gamma_{iq} is the interaction effect for the q-th eigenvector for genotype i
# delta_{iq} is the interaction effect for the q-th eigenvector for environment j
# E_{ij} is a residual term with E_{ij} ~ N(0, sigma^2_E)
# Usually these models have quite complicated restrictions on the gamma/delta/lambda values but Josse et al show that these are not fully necessary

# Likelihood
# Y_{ij} ~ N(mu_{ij}, sigma^2_E)
# with
# mu_{ij} = mu + alpha_i + beta_j + sum_{q=1}^Q lambda_q*gamma_iq*delta_jq

# Priors
# mu ~ N(m, s_mu^2)
# alpha_i ~ N(0, s_alpha^2)
# beta_j ~ N(0, s_beta^2)
# lambda_q ~ N+(0, s_lambda^2) with lambda_1 < lambda_2 < ... < lambda_Q
# Note: N+ means positive-only normal
# gamma_{1q} ~ N+(0, 1)
# gamma_{iq} ~ N(0, 1)
# delta_{jq} ~ N(0, 1)
# sigma_E ~ U(0, S_ME)
# All of the above hyper-parameter values are fixed

# Simulate data -----------------------------------------------------------

# We will follow the simulation strategy detailed in Section 3.1 of the Josse et al paper

# Specify fixed values
Q = 1 # Number of components
I = 10 # Number of genotypes
J = 10# Number of environments
N = I*J # Total number of obs
m = 90
s_mu = 20
s_alpha = 10
s_beta = 10
s_lambda = 10
S_ME = 10

# Some further fixed values
mu = 10
# sigma_E = 3/2 # Not sure why S_ME was specified if they're also giving sigma_E
sigma_E = 1
alpha = seq(-3,3, length.out = I)
beta = seq(-4,4, length.out = J)
lambda_1 = 12
gamma = seq(2, -2,length.out = I)/sqrt(10)
delta = seq(-0.5, 0.5,length.out = J)

# Now simulate the values
set.seed(123)
G_by_E = expand.grid(1:I, 1:J) ## setting the interaction matrix
mu_ij = mu + alpha[G_by_E[,1]] + beta[G_by_E[,2]]  + lambda_1 * gamma[G_by_E[,1]] * delta[G_by_E[,2]] ## maybe insert lambda2
Y = rnorm(N, mu_ij, sigma_E) ## response variable

cbind(G_by_E, Y) %>% 
  group_by(Var1) %>% 
  summarise(meanY = mean(Y),
            n= n())

cbind(G_by_E, Y) %>% 
  group_by(Var2) %>% 
  summarise(meanY = mean(Y),
            n = n())

# Can create some plots
qplot(x = G_by_E[,1], y = Y, geom = 'boxplot', group = G_by_E[,1], xlab = 'Genotype')
qplot(x = G_by_E[,2], y = Y, geom = 'boxplot', group = G_by_E[,2], xlab = 'Environment')


# Q = 1 model -------------------------------------------------------------

# This is the simple Q = 1 model - only here for understanding
# Jags code to fit the model to the simulated data
model_code = '
model
{
  # Likelihood
  for (k in 1:N) {
  Y[k] ~ dnorm(mu[k], sigma_E^-2)
  mu[k] = mu_all + alpha[genotype[k]] + beta[environment[k]] + lambda_1 * gamma[genotype[k]] * delta[environment[k]]
  }
  # Priors
  mu_all ~ dnorm(0, s_mu^-2) # Prior on grand mean
  for(i in 1:I) {
  alpha[i] ~ dnorm(0, s_alpha^-2) # Prior on genotype effect
  }
  gamma[1] ~ dnorm(0, 1)T(0,) # First one is restriced to be positive
  for(i in 2:I) {
  gamma[i] ~ dnorm(0, 1) # Prior on genotype interactions
  }
  for(j in 1:J) {
  beta[j] ~ dnorm(0, s_beta^-2) # Prior on environment effect
  delta[j] ~ dnorm(0, 1) # Prior on environment interactions
  }
  # Prior on first (and only) eigenvalue
  lambda_1 ~ dnorm(0, s_lambda^-2)T(0,)
  # Prior on residual standard deviation
  sigma_E ~ dunif(0, S_ME)
}
'

# Set up the data
model_data = list(N = N,
                  Y = Y,
                  I = I,
                  J = J,
                  genotype = G_by_E[,1],
                  environment = G_by_E[,2],
                  s_mu = s_mu,
                  s_alpha = s_alpha,
                  s_beta = s_beta,
                  s_lambda = s_lambda,
                  S_ME = S_ME)

# Choose the parameters to watch
model_parameters =  c("alpha", "beta", "lambda_1", "gamma", "delta",
                      'sigma_E')

# Run the model
model_run = jags(data = model_data,n.chains=5,
                 parameters.to.save = model_parameters,
                 model.file=textConnection(model_code))

# Look at the results
plot(model_run)


# Can compare these to the true values - looks ok but not amazing. Seems to have got things right in the main
# Convergence is good


hist(model_run$BUGSoutput$sims.list$alpha[,3])
hist(model_run$BUGSoutput$sims.list$gamma[,1])

# Second model - general Q ------------------------------------------------

model_code = '
model
{
  # Likelihood
  for (k in 1:N) {
  Y[k] ~ dnorm(mu[k], sigma_E^-2)
  mu[k] = mu_all + alpha[genotype[k]] + beta[environment[k]] + sum(lambda * gamma[genotype[k],1:Q] * delta[environment[k],1:Q])
  }
  # Priors
  mu_all ~ dnorm(0, s_mu^-2) # Prior on grand mean
  for(i in 1:I) {
  alpha[i] ~ dnorm(0, s_alpha^-2) # Prior on genotype effect
  }
  for(j in 1:J) {
  beta[j] ~ dnorm(0, s_beta^-2) # Prior on environment effect
  }
  # Priors on gamma
  for(q in 1:Q) {
  gamma[1, q] ~ dnorm(0, 1)T(0,) # First one is restriced to be positive
  for(i in 2:I) {
  gamma[i, q] ~ dnorm(0, 1) # Prior on genotype interactions
  }
  }
  # Priors on delta
  for(q in 1:Q) {
  for(j in 1:J) {
  delta[j, q] ~ dnorm(0, 1) # Prior on environment interactions
  }
  }
  # Prior on eigenvalues
  for(q in 1:Q) {
  lambda_raw[q] ~ dnorm(0, s_lambda^-2)T(0,)
  }
  lambda = sort(lambda_raw)
  # Prior on residual standard deviation
  sigma_E ~ dunif(0, S_ME)
}
'

# Set up the data
model_data = list(N = N,
                  Y = Y,
                  I = I,
                  J = J,
                  Q = 2, # Set Q to be 2 even though the simulation was for Q = 1
                  genotype = G_by_E[,1],
                  environment = G_by_E[,2],
                  s_mu = s_mu,
                  s_alpha = s_alpha,
                  s_beta = s_beta,
                  s_lambda = s_lambda,
                  S_ME = S_ME)

# Choose the parameters to watch
model_parameters =  c("alpha", "beta", "lambda", "gamma", "delta",
                      'sigma_E')

# Run the model
model_run = jags(data = model_data,
                 parameters.to.save = model_parameters,
                 model.file=textConnection(model_code))

# Plot the results
plot(model_run)
print(model_run)
mean(model_run$BUGSoutput$sims.list$alpha[,1])
summary(model_run$BUGSoutput$sims.list$alpha[,1])
# Seems to work ok - might need a longer run to get better convergence
model_run$BUGSoutput$
# Real example ------------------------------------------------------------
# example from vencovsky 19??
### AMMI example Vencovsky material yield in tons/ha maize grain
g1 =c(1587.9, 560.9, 1020.6 ,1449.7, 1489.6)
g2 =c(1386.7, 691.7, 1160.8 ,1591.2, 1235.3)
g3= c(1572.9, 770.4, 1316.2, 1835.9, 1698.0)
g4 =c(1139.7, 734.5, 862.7, 1143.8 ,974.9)
g5 =c(1348.9, 458.2, 663.8, 1021.2, 1116.3)
g6 =c(1061.5, 459.4, 576.7, 948.3, 1013.7)
g7 =c(1590.9, 1104.0, 1286.3, 1250.9, 1502.7)
g8 =c(1223.9, 546.9, 674.3, 1053.7 ,1053.4)
g9 =c(1402.0, 570.9, 664.4, 993.4, 672.9)
g10 =c(1313.6 ,580.1, 596.3, 1185.9, 913.7)

y=c(g1,g2,g3,g4,g5,g6,g7,g8,g9,g10)

env=rep(c("1","2","3","4","5"),length(levels(as.factor(gen))))
gen=c(c(rep("1",5)),c(rep("2",5)),c(rep("3",5)),c(rep("4",5)),c(rep("5",5)),c(rep("6",5)),c(rep("7",5)),c(rep("8",5)),c(rep("9",5)),c(rep("10",5)))
g_e_long=data.frame(y,gen,env)
str(g_e_long)

model_data = list(N = 50,
                  Y = y,
                  I = 10,
                  J = 5,
                  Q = 2, # Set Q to be 2 even though the simulation was for Q = 1
                  genotype = gen,
                  environment = env,
                  s_mu = s_mu,
                  s_alpha = s_alpha,
                  s_beta = s_beta,
                  s_lambda = s_lambda,
                  S_ME = S_ME)

# Choose the parameters to watch
model_parameters =  c("alpha", "beta", "lambda", "gamma", "delta",
                      'sigma_E')

# Run the model
model_run = jags(data = model_data,
                 parameters.to.save = model_parameters,
                 model.file=textConnection(model_code))

# Plot the results
plot(model_run)
print(model_run)
mean(model_run$BUGSoutput$sims.list$alpha[,1])
summary(model_run$BUGSoutput$sims.list$alpha[,1])
# Seems to work ok - might need a longer run to get better convergence





# Data wrangling and jags code to run the model on a real data set in the data directory


# Other tasks -------------------------------------------------------------

# Perhaps exercises, or other general remarks

## to create a biplot we need to make the following analogy :
## to create the biplot -- last step 
## we need  G and H' such as GE=G.H' 
## G=U.S(1/2)  H=S(1/2).V'
## biplot classical ammi
#g_e_res_scale=scale(g_e_res,center = TRUE,scale = TRUE)
#s=svd(g_e_res_scale,nv=min(9,4))
#s
### here d is the s matrix from GE=USV
### u is -1* the u matrix from GE=USV'  
### v is -1* the v matrix from GE=USV'
#gamma=-1*s$u # we correct the svd and get the singular vector columns  
#v=-1*s$v 
#lambda=s$d # is the matrix with the single values 
#delta=t(v)#

# thus we assume that the gamma delta and lambda are analogous to 
# gamma would be the values of U matrix in normal SVD
# lambda would be the values of de in normal SVD
# delta would be analogous to v 

## to create the biplot -- last step 
## we need  G and H' such as GE=G.H' 
## G=U.S(1/2)  H=S(1/2).V'
## U is 
post=print(model_run)
gamma_2=post$mean$gamma
lambda_2=post$mean$lambda
delta_2=t(post$mean$delta)
d_til_2=diag(lambda_2)

g_matrix=gamma_2%*%(d_til_2^(1/2))
t_h=(d_til_2^(1/2))%*%(delta_2)

### calculate in line 259 

## data as it will come in datasets

data_as_received=data.frame(y,gen=as.factor(gen),env=as.factor(env))
head(data_as_received)

gen_means=with(data_as_received, tapply(y, gen, mean))
env_means=with(data_as_received, tapply(y, env, mean))
av=c(gen_means,env_means)
pc_1=as.numeric(c(g_matrix[,1],t_h[1,]))## first genotypes and second env
pc_2=as.numeric(c(g_matrix[,2],t_h[2,]))## the same as above
fac=c(rep("gen",10),rep("env",5))
gis = sprintf("gen[%s]",seq(1:10))
env= sprintf("env[%s]",seq(1:5))
sam=c(gis,env)

my_df=data.frame(fac,sam,av,pc_1,pc_2)
head(my_df)

## PCA are not standardized 
ggplot(data=my_df,aes(x=av,y=pc_1,label=sam))+geom_text(aes(colour=fac))+geom_vline(xintercept =mean(av))+
  geom_hline(yintercept = 0)+ggtitle("AMMI1-PCA x Average")
## include arros

## PC1xPC2

### creating a dataset just for the arrows 
my_df_arrows=my_df %>% 
  filter(fac=="env")

p=ggplot(data=my_df,aes(x=pc_1,y=pc_2,label=sam))+
  geom_text(aes(colour=fac))+geom_vline(xintercept = 0)+
  geom_hline(yintercept=0)
p

p+geom_segment(data=my_df_arrows,aes(x=0,y=0,xend=pc_1,yend=pc_2,group=sam),
               arrow=arrow(length=unit(2,"mm")),color="black")
z=p+geom_segment(data=my_df_arrows,aes(x=0,y=0,xend=pc_1,yend=pc_2,group=sam),
                 arrow=arrow(length=unit(2,"mm")),color="black")
library(plotly)
ggplotly(z)

### maybe use transparency 
###checking g1


# next steps  checking biplots , cretating simulation with missing, insert a prior the for the missing data 
## 7th december course on missing data 2-5pm 

### check if the jags code x the correct values and check if matches the code from genetic class
### try to plot the effects of Phenotypes (alpha) x biplot (PC1x main effects of genotypes)
### interaction graphs . interaction.plot(). ggbiplot() remotely github.
###